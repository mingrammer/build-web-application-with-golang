# 동시성

Go는 21세기의 C언어라고들 말합니다. 여기에는 두 가지 이유가 있는 것 같습니다: 첫 번째는 Go는 간단한 언어이며, 두 번째는 Go는 최근의 핫한 주제인 동시성을 언어 차원에서 지원하기 때문입니다.

## 고루틴

고루틴과 동시성은 Go의 핵심 설계에 내장되어 있습니다. 이들은 스레드와 비슷하지만 다르게 동작합니다. 12개 이상의 고루틴은 5 또는 6개의 기본 스레드만을 가질 수 있습니다. Go는 또한 고루틴간의 메모리를 공유하는 방법도 완벽히 지원합니다. 하나의 고루틴은 보통 4~5 KB의 스택 메모리를 사용합니다. 그렇기 때문에, 한 컴퓨터에서 수천개의 고루틴을 돌리는건 어렵지 않습니다. 고루틴은 시스템 스레드보다 더욱 가볍고 효율적이며 편리합니다.

goroutines run on the thread manager at runtime in Go. We use the `go` keyword to create a new goroutine, which is a function at the underlying level ( ***main() is a goroutine*** ).

```go
go hello(a, b, c)
```
예시를 봅시다.


```go
package main

import (
	"fmt"
	"runtime"
)

func say(s string) {
	for i := 0; i < 5; i++ {
    	runtime.Gosched()
    	fmt.Println(s)
	}
}

func main() {
	go say("world") // 새로운 고루틴을 만듬
	say("hello") // 현재 고루틴 (메인 고루틴)
}
```

출력값：

	hello
	world
	hello
	world
	hello
	world
	hello
	world
	hello

Go의 동시성을 `go` 키워드를 사용해 매우 쉽게 사용할 수 있음을 볼 수 있습니다. 위 예제에서, 두 고루틴은 메모리의 일부를 공유하지만, 우리는 다음의 설계 레시피를 따르는 것이 좋습니다: 통신을 위해 공유 데이터를 사용하지말고, 데이터를 공유하기 위해 통신을 사용하라.

`runtime.Gosched()`는 CPU가 다른 고루틴을 실행한 후 어떤 지점으로 다시 돌아오게함을 의미합니다.

Go 1.5 부터 런타임은 동시 실행을 위해 CPU에서 사용 가능한 코어수를 지칭하는 GOMAXPROCS에 의해 정의되는 기본 스레드 수를 설정합니다.

Go 1.5 이전 버전에서는, 스케쥴러가 모든 고루틴을 실행하기 위해 단 하나의 스레드만 사용하며, 이는 동시성만을 구현함을 의미합니다. 병렬 처리의 이점을 얻기 위해 더 많은 CPU 코어를 사용하고자 할 때에는, 사용하고싶은 코어의 갯수를 설정하기 위해 `runtime.GOMAXPROCS(n)`를 호출해야 합니다.

## 채널

고루틴들은 동일한 메모리 주소 공간에서 실행되므로 공유 메모리에 접근하기 위해서는 동기화를 유지해야합니다. 서로 다른 고루틴간 통신은 어떻게 할까요? Go는 `channel`이라고 하는 훌륭한 통신 메커니즘을 사용합니다. `channel`은 유닉스 쉘에서의 양방향 파이프라인과 유사합니다: 데이터 송신과 수신을 위해 `channel`을 사용합니다. 채널로 사용될 수 있는 유일한 데이터 타입은 `channel`이며 `chan` 키워드를 사용하빈다. 새로운 `channel`을 만들기 위해 `make`를 사용해야함을 숙지하세요.

```go
ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
```

채널은 데이터를 보내거나 받기위해 `<-` 연산자를 사용합니다.

```go
ch <- v    // v를 ch 채널로 보냄
v := <-ch  // ch로부터 데이터를 받고 v에 할당
```

추가 예제를 살펴봅시다.


```go
package main
import "fmt"

func sum(a []int, c chan int) {
	total := 0
	for _, v := range a {
    total += v
	}
	c <- total  // total을 c로 보냄
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)
	x, y := <-c, <-c  // c에서 데이터를 가져옴

	fmt.Println(x, y, x + y)
}
```

기본적으로 채널에서 데이터를 송신하고 수신하는건 블로킹 메커니즘이기 때문에, 고루틴 동기화가 매우 쉽습니다. 블로킹이란 고루틴이 데이터를 빈 채널로부터 수신하고 있으면 더 이상 실행이 진행되지 않는다는 의미입니다. 다시 말하면, 고루틴은 채널에 데이터가 들어오기 전까지 실행을 진행하지 않습니다. (`ch<-5`와 같이 데이터를 수신받음)

## 버퍼 채널

위에서는 버퍼가 없는 채널을 소개했습니다. Go는 하나 이상의 원소를 저장할 수 있는 버퍼 채널 또한 지원합니다. 예를 들어, `ch := make(chan bool, 4)`은 4개의 불리언 원소를 저장할 수 있는 채널을 만들며, 블로킹 없이 4개의 원소를 송신할 수 있지만, 만약 채널 데이터를 수신하는 고루틴이 없을 때 5개의 원소를 송신하려고 하면 송신 고루틴은 블로킹됩니다.


```go
ch := make(chan type, n)

n == 0 ! non-buffer（block）
n > 0 ! buffer（non-block until n elements in the channel）
```

다음의 코드를 실행해보고 값을 바꿔보세요.


```go
package main
import "fmt"

func main() {
	c := make(chan int, 2)  // 2를 1로 바꾸면 런타임에러가 뜨지만, 3은 괜찮습니다.
	c <- 1
	c <- 2
	fmt.Println(<-c)
	fmt.Println(<-c)
}
```

## Range and Close

슬라이스와 맵에서처럼 버퍼 채널에도 `range`를 사용할 수 있습니다.


```go
package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
	x, y := 1, 1
	for i := 0; i < n; i++ {
    	c <- x
    	x, y = y, x + y
	}
	close(c)
}

func main() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)
	for i := range c {
	    fmt.Println(i)
	}
}
```

`for i := range c`는 채널이 닫힐 때까지 채널에서 데이터를 계속 수신합니다. 위 예제에서 채널을 닫기 위해서는 `close` 키워드를 사용합니다. 닫힌 채널에서는 데이터를 송수신 할 수 없습니다. 채널이 닫혀있음을 확인하기위해 `v, ok := <-ch`를 사용할 수 있습니다. `ok`가 false를 반환하는건 채널에 데이터가 없으며 채널이 닫혔음을 의미합니다.

Remember to always close channels in producers and not in consumers, or it's very easy to get into panic status. 

여러분이 기억해야할 또 다른 하나는 채널이 파일과 다르다는 것입니다. 채널이 정말로 필요없어지거나 range 루프를 빠져나가야 하는 경우가 아니라면 채널을 자주 종료할 필요는 없습니다.

## Select

위 예제에서 우리는 하나의 채널만 사용했는데, 하나 이상의 채널은 어떻게 다룰까요? Go에는 다중 채널을 받을 수 있는 `select`라는 키워드가 있습니다.

`select`는 기본적으로 블로킹 메커니즘을 따르며 채널중 하나에 데이터가 송신되거나 수신되는 경우에만 실행을 진행합니다. 여러개의 채널이 동시에 사용 가능한 경우에는 채널을 랜덤으로 선택하여 실행합니다. 


```go
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 1, 1
	for {
    	select {
    	case c <- x:
        	x, y = y, x + y
    	case <-quit:
    	fmt.Println("quit")
        	return
    	}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
    	for i := 0; i < 10; i++ {
        	fmt.Println(<-c)
    	}
    	quit <- 0
	}()
	fibonacci(c, quit)
}
```

`select`에는 `switch`에 있는 `default` 케이스 또한 가지고 있습니다. 모든 채널이 사용 불가능한 경우, 이는 default 케이스를 실행합니다. (이는 더 이상 채널을 대기하지 않습니다.)

```go
select {
case i := <-c:
	// use i
default:
	// executes here when c is blocked
}
```

## 타임아웃

가끔 고루틴이 블로킹되는 경우가 있습니다. 전체 프로그램이 블로킹되는걸 방지하기 위해 이를 어떻게 피할 수 있을까요? 간단합니다, select에 타임아웃을 설정하면됩니다.

```go
func main() {
	c := make(chan int)
	o := make(chan bool)
	go func() {
    	for {
        	select {
            	case v := <- c:
               		println(v)
            	case <- time.After(5 * time.Second):
                	println("timeout")
                	o <- true
                	break
        	}
    	}
	}()
	<- o
}
```

## 런타임 고루틴

`runtime` 패키지는 고루틴을 다루기 위한 몇 가지 함수들을 가지고 있습니다.

- `runtime.Goexit()`

  현재 고루틴을 나갑니다. 하지만 지연된(defered) 함수는 그대로 실행됩니다.

- `runtime.Gosched()`

  스케쥴러가 다른 고루틴을 실행시킨뒤 특정 지점으로 돌아갈 수 있게 해줍니다.

- `runtime.NumCPU() int`

  CPU 코어수를 반환합니다.

- `runtime.NumGoroutine() int`

  고루틴의 개수를 반환합니다.

- `runtime.GOMAXPROCS(n int) int`

  사용할 CPU 코어수를 설정합니다.

## 링크

- [목차](preface.md)
- 이전 글: [인터페이스](02.6.md)
- 다음 글: [요약](02.8.md)
