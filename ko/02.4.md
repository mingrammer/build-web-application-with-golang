# 2.4 구조체

## struct

다른 프로그래밍 언어와 마찬가지로 Go에서 다른 속성이나 필드의 컨테이너 타입을 새로 정의 할 수 있습니다. 예를 들어 사람을 나타내기 위해 이름과 나이 필드를 가진 `person`이라는 타입을 정의할 수 있습니다. 이런 종류의 타입을 `struct`라고 부릅니다.

```go
type person struct {
        name string
        age int
}
```

`struct`를 정의하는 것이 얼마나 쉬운지 보세요!

위 구조체에는 2개의 필드가 있습니다.

- `name`은 사람의 이름을 저장하는 데 사용되는 `string`입니다.
- `age`는 사람의 나이를 저장하는 데 사용되는 `int`입니다.

이것을 어떻게 사용하는지 살펴봅시다.

```go
type person struct {
        name string
        age int
}

var P person  // P는 person 타입입니다.

P.name = "Astaxie"  // p의 'name' 필드에 "Astaxie"를 할당합니다.
P.age = 25  // p의 'age' 필드에 25를 할당합니다.
fmt.Printf("The person's name is %s\n", P.name)  // p의 'name' 필드에 접근합니다.
```

구조체를 초기화하는 세 가지 방법이 더 있습니다.

- 순서에 따라 초기값을 할당합니다.

```go
P := person{"Tom", 25}
```

- 구조체를 순서없이 초기화하려면 `field:value` 형식을 사용합니다.

```go
P := person{age:24, name:"Bob"}
```

- 익명 구조체를 정의한 다음 초기화합니다.

```go
P := struct{name string; age int}{"Amy",18}

```

완벽한 예제코드를 한번 살펴봅시다.
```go
package main
import "fmt"

// 새로운 타입을 정의합니다.
type person struct {
    name string
    age int
}

// 두 사람의 나이를 비교 한 다음 나이가 많은 사람과 나이 차이를 반환합니다.
// 구조체는 값을 전달합니다.
func Older(p1, p2 person) (person, int) {
    if p1.age>p2.age {  
        return p1, p1.age-p2.age
    }
    return p2, p2.age-p1.age
}

func main() {
    var tom person

    // 초기화
    tom.name, tom.age = "Tom", 18

    // "field:value" 형식으로 2개의 변수를 초기화합니다.
    bob := person{age:25, name:"Bob"}

    // 2개의 변수를 순서대로 초기화합니다.
    paul := person{"Paul", 43}

    tb_Older, tb_diff := Older(tom, bob)
    tp_Older, tp_diff := Older(tom, paul)
    bp_Older, bp_diff := Older(bob, paul)

    fmt.Printf("Of %s and %s, %s is older by %d years\n", tom.name, bob.name, tb_Older.name, tb_diff)

    fmt.Printf("Of %s and %s, %s is older by %d years\n", tom.name, paul.name, tp_Older.name, tp_diff)

    fmt.Printf("Of %s and %s, %s is older by %d years\n", bob.name, paul.name, bp_Older.name, bp_diff)
}
```

### 구조체의 임베딩 필드

방금 필드 이름과 타입으로 구조체를 정의하는 방법을 소개했습니다. 또한 Go는 이름없이 타입만 있는 필드를 제공해주기도 하는데 이것을 임베딩 필드라고 부릅니다.

임베딩 필드의 타입이 구조체인 경우 암시적으로 임베딩 구조체를 사용하는 구조체는 임베딩 구조체의 필드를 갖게됩니다.

예제 하나를 보겠습니다.

```go
package main
import "fmt"

type Human struct {
    name string
    age int
    weight int
}

type Student struct {
    Human  // 임베딩 필드는 Student 구조체가 Human이 가진 모든 필드를 포함한다는 것을 의미합니다.
    specialty string
}

func main() {
    // student를 초기화합니다.
    mark := Student{Human{"Mark", 25, 120}, "Computer Science"}

    // 필드에 접근합니다.
    fmt.Println("His name is ", mark.name)
    fmt.Println("His age is ", mark.age)
    fmt.Println("His weight is ", mark.weight)
    fmt.Println("His specialty is ", mark.specialty)
    // 특기를 변경합니다.
    mark.specialty = "AI"
    fmt.Println("Mark changed his specialty")
    fmt.Println("His specialty is ", mark.specialty)
    // 나이를 변경합니다.
    fmt.Println("Mark become old")
    mark.age = 46
    fmt.Println("His age is", mark.age)
    // 몸무게를 변경합니다.
    fmt.Println("Mark is not an athlet anymore")
    mark.weight += 60
    fmt.Println("His weight is", mark.weight)
}
```

![](images/2.4.student_struct.png?raw=true)

Figure 2.7 Student에서의 임베딩과 Human

우리는 Human과 마찬가지로 학생의 `age`와 `name` 필드에 접근 할 수 있었습니다. 이것이 임베딩 필드가 작동하는 방식입니다. 정말 멋지지 않나요? 잠깐만요 더 멋진 것이 있습니다. 이 임베딩 필드에서 Student를 사용해 Human에 접근 할 수도 있습니다!

```go
mark.Human = Human{"Marcus", 55, 220}
mark.Human.age -= 1
```

Go에선 모든 타입을 임베딩 필드로 사용할 수 있습니다.

```go
package main
import "fmt"

type Skills []string

type Human struct {
    name string
    age int
    weight int
}

type Student struct {
    Human  // 임베딩 필드로 사용되는 구조체
    Skills // 임베딩 필드로 사용되는 문자열 슬라이스
    int    // 임베딩 필드로 사용되는 기본 내장 타입
    specialty string
}

func main() {
    // Student Jane을 초기화합니다.
    jane := Student{Human:Human{"Jane", 35, 100}, specialty:"Biology"}
    // 필드에 접근합니다.
    fmt.Println("Her name is ", jane.name)
    fmt.Println("Her age is ", jane.age)
    fmt.Println("Her weight is ", jane.weight)
    fmt.Println("Her specialty is ", jane.specialty)
    // skill 필드의 값을 변경합니다.
    jane.Skills = []string{"anatomy"}
    fmt.Println("Her skills are ", jane.Skills)
    fmt.Println("She acquired two new ones ")
    jane.Skills = append(jane.Skills, "physics", "golang")
    fmt.Println("Her skills now are ", jane.Skills)
    // 임베딩 필드의 값을 변경합니다.
    jane.int = 3
    fmt.Println("Her preferred number is ", jane.int)
}
```

위의 예제에서 우리는 모든 타입이 임베딩 필드로 쓰일 수 있고 함수를 사용하여 필드를 조작 할 수 있다는 것을 볼 수 있었습니다.

그러나 한 가지 더 문제가 있습니다. Human에 `phone`라는 필드가 있고 Student에게 같은 이름의 필드가 있다면 어떻게 해야할까요?

그것을 해결하는 방법은 아주 간단합니다. 바깥 쪽 필드는 우선 엑세스 권한을 가지며, 이는 `student.phone`에 접근 할 때 Human 구조체에 있는 것이 아니라 Student 구조체의 phone 필드를 가져옵니다. 이 기능은 단순히 필드 오버로딩이라고 볼 수 있습니다.

```go
package main
import "fmt"

type Human struct {
    name string
    age int
    phone string  // Human은 phone 필드를 가지고 있습니다.
}

type Employee struct {
    Human  // Human 임베딩 필드를 사용합니다.
    specialty string
    phone string  // Emplyee의 phone 필드입니다.
}

func main() {
    Bob := Employee{Human{"Bob", 34, "777-444-XXXX"}, "Designer", "333-222"}
    fmt.Println("Bob's work phone is:", Bob.phone)
    // Human에 있는 phone 필드에 접근합니다.
    fmt.Println("Bob's personal phone is:", Bob.Human.phone)
}
```

## 링크

- [목차](preface.md)
- 이전 글: [제어문과 함수](02.3.md)
- 다음 글: [객체 지향](02.5.md)
