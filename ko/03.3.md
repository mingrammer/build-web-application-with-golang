# 3.3 웹에서의 Go 동작 원리

우리는 이전 글에서 간단한 웹 서버를 만들기 위해 `net/http` 패키지를 사용하는 방법을 배웠고, 모든 작동 원리는 이 글의 첫 번째 절에서 이야기 할 내용과 같습니다.

## 웹 원리의 개념

Request: POST, GET, 쿠키 및 URL을 포함하여 사용자의 데이터를 요청합니다.

Response: 응답 데이터를 서버에서 클라이언트로 전송합니다.

Conn: 클라이언트와 서버 간의 연결.

Handler: 요청 처리 로직 및 응답 생성.

## http 패키지 작동 메커니즘

다음 그림은 Go 웹 서버의 작업 흐름을 보여줍니다.

![](images/3.3.http.png?raw=true)

Figure 3.9 http 작업 흐름

1. 특정 포트에서 클라이언트 요청을 대기하는 소켓을 만듭니다.
2. 클라이언트의 요청을 받아들입니다.
3. 요청을 처리하고 HTTP 헤더를 읽습니다. 요청에서 POST 메서드를 사용하는 경우 메시지 본문에서 데이터를 읽고 이를 핸들러로 전달합니다. 마지막으로 소켓은 응답 데이터를 클라이언트에 반환합니다.

다음 세 가지 질문에 대한 답변을 알게되면 Go에서 웹이 어떻게 작동하는지 쉽게 알 수 있습니다.

- 포트에서 수신을 어떻게 하나요?
- 클라이언트의 요청을 어떻게 받아들일까요?
- 핸들러를 어떻게 할당 하나요?

이전 글에서는 Go가 `ListenAndServe`를 사용해 서버 객체 `call net.Listen("tcp", addr)`를 초기화하여 TCP 리스너를 설정하고 특정 주소와 포트를 수신하는 것을 봤습니다.

이제 http 패키지의 소스 코드를 살펴 보겠습니다.

```go
//빌드 버전 go 1.1.2.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	var tempDelay time.Duration // 접속 실패시 대기 시간
	for {
		rw, e := l.Accept()
		if e != nil {
			if ne, ok := e.(net.Error); ok && ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay > max {
					tempDelay = max
				}
				log.Printf("http: Accept error: %v; retrying in %v", e, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return e
		}
		tempDelay = 0
		c, err := srv.newConn(rw)
		if err != nil {
			continue
		}
		go c.serve()
	}
}
```


포트를 리스닝한 다음 클라이언트의 요청은 어떻게 받을까요? 위의 코드에서는 포트 수신을 수행한 후 `srv.Serve(net.Listener)` 함수를 호출하고 있습니다. 이 함수는 클라이언트의 요청 정보를 처리하고 있습니다. 이 함수는`for{}`에서 먼저 Listener를 통해 요청을 받은 후, `Conn`을 만들고 마지막으로 단일 고루틴을 엽니다. 이 요청의 데이터를 conn의 인수로 전달합니다. `go c.serve()`는 멀티 스레드로 동작합니다. 사용자의 요청은 새로운 고루틴 위에서 이루어지며 서로 영향을주지 않습니다.

요청을 처리하기 위한 함수들은 어떻게 사용할 수 있을까요? `conn`는 처음에 `c.ReadRequest()`를 파싱 한 다음 대응하는 핸들러를 얻습니다: `handler := sh.srv.Handler`는 `ListenAndServe`를 호출 할 때 우리가 건네 준 두 번째 인자입니다. 우리가 `nil`을 통과했기 때문에 Go는 기본 핸들러인 `handler = DefaultServeMux`를 초기화합니다. 그렇다면 `DefaultServeMux`는 여기서 어떤 일을 할까요? 특정 URL에 대한 핸들러 함수를 호출 할 수있는 라우터 변수이고 우리는 이미 이것을 설정했습니다! 우리는 `http.HandleFunc("/", sayhelloName)`을 사용했던 첫 번째 줄에서 이 작업을 수행했습니다. 이 기능을 사용하여 "/" 경로에 대한 라우터 규칙을 등록합니다. URL이 `/`이면 라우터는 `sayhelloName` 함수를 호출합니다. DefaultServeMux는 ServerHTTP를 호출하여 다른 경로에 대한 핸들러 함수를 가져오고 이 경우에는 `sayhelloName`을 호출합니다. 마지막으로 서버는 데이터를 쓰고 클라이언트에 응답합니다.

자세한 작업 흐름:

![](images/3.3.illustrator.png?raw=true)

Figure 3.10 HTTP 요청 처리의 작업 흐름

이제는 여러분은 Go에서 웹서버가 어떻게 동작하는지 알 수 있을겁니다.

## 링크

- [목차](preface.md)
- 이전 글: [간단한 웹 서버 만들기](03.2.md)
- 다음 글: [Http 패키지 살펴보기](03.4.md)
